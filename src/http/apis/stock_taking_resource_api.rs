/*
 * # Documentation   The Fortnox API is organized around REST. This means that weâ€™ve designed it to have resource-oriented URLs and be as predictable as possible for you as developer.  It also means that we use HTTP status codes when something goes wrong and HTTP verbs understod by many API clients around the web.  We use a modified version of OAuth2 for authentication to offer a secure way for both you and our users to interact.  The API is generally built to support both XML and JSON but in this documentation all the examples will be in JSON.  We encourage you to read all the articles in the [general information section](https://developer.fortnox.se/general/)</a> first, before going forward and learning about the different resources.  This to ensure you get an understanding of some of the shared components of the API such as parameters and error handling.  ## Rate limits  The limit is 4 requests per second per access-token. This equals to a bit more than 200 requests per minute.  [Read more about this here.](https://developer.fortnox.se/general/regarding-fortnox-api-rate-limits/)  ## Query parameters  Use query parameters with the ?-character and separate parameters with the &-character.   **Example:**  GET - https://api.fortnox.se/3/invoices?accountnumberfrom=3000&accountnumberto=4000 Read more about our parameters [here](https://developer.fortnox.se/general/parameters/)   Search the documentation using the search field in the top left corner.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::http::apis::ResponseContent;

/// struct for passing parameters to the method [`add_stock_taking_rows`]
#[derive(Clone, Debug, Default)]
pub struct AddStockTakingRowsParams {
    /// Stock Taking document id.
    pub id: i64,
    /// A list of <code>StockTakingRows</code>.
    pub rows: Option<Vec<crate::http::models::StockTakingRow>>,
}

/// struct for passing parameters to the method [`add_stock_taking_rows_by_filter`]
#[derive(Clone, Debug, Default)]
pub struct AddStockTakingRowsByFilterParams {
    /// Stock Taking document id.
    pub id: i64,
    pub item_ids: Option<Vec<String>>,
    pub supplier_numbers: Option<Vec<String>>,
    pub stock_point_ids: Option<Vec<String>>,
    pub stock_location_ids: Option<Vec<String>>,
    pub transaction_date: Option<String>,
    pub item_id_search: Option<String>,
    pub item_description_search: Option<String>,
    pub exclude_zero_balance_items: Option<bool>,
    pub exclude_non_inbound_items: Option<bool>,
}

/// struct for passing parameters to the method [`create_stock_taking_resource`]
#[derive(Clone, Debug, Default)]
pub struct CreateStockTakingResourceParams {
    /// stock taking
    pub stock_taking: Option<crate::http::models::StockTaking>,
}

/// struct for passing parameters to the method [`delete_stock_taking`]
#[derive(Clone, Debug, Default)]
pub struct DeleteStockTakingParams {
    /// Stock Taking document id.
    pub id: i64,
}

/// struct for passing parameters to the method [`delete_stock_taking_row`]
#[derive(Clone, Debug, Default)]
pub struct DeleteStockTakingRowParams {
    /// Stock Taking document id.
    pub id: i64,
    /// row id
    pub row_id: String,
}

/// struct for passing parameters to the method [`delete_stock_taking_row_by_filter`]
#[derive(Clone, Debug, Default)]
pub struct DeleteStockTakingRowByFilterParams {
    /// Stock Taking document id.
    pub id: i64,
    pub item_ids: Option<Vec<String>>,
    pub supplier_numbers: Option<Vec<String>>,
    pub stock_point_ids: Option<Vec<String>>,
    pub stock_location_ids: Option<Vec<String>>,
    pub transaction_date: Option<String>,
    pub item_id_search: Option<String>,
    pub item_description_search: Option<String>,
    pub exclude_zero_balance_items: Option<bool>,
}

/// struct for passing parameters to the method [`get_all_stock_taking_resource`]
#[derive(Clone, Debug, Default)]
pub struct GetAllStockTakingResourceParams {
    /// Include only stock takings with the given state.
    pub state: Option<String>,
    /// Include only stock takings with the given item.
    pub item_id: Option<String>,
}

/// struct for passing parameters to the method [`get_candidate_rows`]
#[derive(Clone, Debug, Default)]
pub struct GetCandidateRowsParams {
    /// Stock Taking document id.
    pub id: i64,
    pub item_ids: Option<Vec<String>>,
    pub supplier_numbers: Option<Vec<String>>,
    pub stock_point_ids: Option<Vec<String>>,
    pub stock_location_ids: Option<Vec<String>>,
    pub transaction_date: Option<String>,
    pub item_id_search: Option<String>,
    pub item_description_search: Option<String>,
    pub exclude_zero_balance_items: Option<bool>,
    /// Include items that do not exist on inbound deliveries.
    pub include_non_inbound_items: Option<bool>,
}

/// struct for passing parameters to the method [`get_rows`]
#[derive(Clone, Debug, Default)]
pub struct GetRowsParams {
    /// Stock Taking document id.
    pub id: i64,
    pub item_ids: Option<Vec<String>>,
    pub supplier_numbers: Option<Vec<String>>,
    pub stock_point_ids: Option<Vec<String>>,
    pub stock_location_ids: Option<Vec<String>>,
    pub transaction_date: Option<String>,
    pub item_id_search: Option<String>,
    pub item_description_search: Option<String>,
    pub exclude_zero_balance_items: Option<bool>,
    /// Secondary sorting column
    pub secondarysortby: Option<String>,
    /// Secondary sorting order
    pub secondaryorder: Option<String>,
    pub state_filter: Option<String>,
    /// the row number to start the search from, used with startingItemId to jump to specific rows, can be empty
    pub starting_row_no: Option<i32>,
    /// the itemId that should be on top of the rows list (used to jump to specific row), can be empty
    pub starting_item_id: Option<String>,
}

/// struct for passing parameters to the method [`get_stock_taking_resource`]
#[derive(Clone, Debug, Default)]
pub struct GetStockTakingResourceParams {
    /// Stock Taking document id.
    pub id: i64,
}

/// struct for passing parameters to the method [`release_stock_taking_resource`]
#[derive(Clone, Debug, Default)]
pub struct ReleaseStockTakingResourceParams {
    /// Stock Taking document id.
    pub id: i64,
}

/// struct for passing parameters to the method [`update_stock_taking_resource`]
#[derive(Clone, Debug, Default)]
pub struct UpdateStockTakingResourceParams {
    /// Stock Taking document id.
    pub id: i64,
    /// stock taking
    pub stock_taking: Option<crate::http::models::StockTaking>,
}

/// struct for passing parameters to the method [`void_stock_taking`]
#[derive(Clone, Debug, Default)]
pub struct VoidStockTakingParams {
    /// Stock Taking document id.
    pub id: i64,
}

/// struct for typed errors of method [`add_stock_taking_rows`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddStockTakingRowsError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_stock_taking_rows_by_filter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddStockTakingRowsByFilterError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_stock_taking_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateStockTakingResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_stock_taking`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteStockTakingError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_stock_taking_row`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteStockTakingRowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_stock_taking_row_by_filter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteStockTakingRowByFilterError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_stock_taking_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllStockTakingResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_candidate_rows`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCandidateRowsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rows`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRowsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_stock_taking_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStockTakingResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`release_stock_taking_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReleaseStockTakingResourceError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_stock_taking_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStockTakingResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`void_stock_taking`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VoidStockTakingError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// Add rows to a stock taking.  If you add an already existing row noting happens.
pub async fn add_stock_taking_rows(
    configuration: &configuration::Configuration,
    params: AddStockTakingRowsParams,
) -> Result<(), Error<AddStockTakingRowsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let rows = params.rows;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}/rows",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&rows);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AddStockTakingRowsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add all matching candidate rows to a stock taking, as specified by filters.
pub async fn add_stock_taking_rows_by_filter(
    configuration: &configuration::Configuration,
    params: AddStockTakingRowsByFilterParams,
) -> Result<i32, Error<AddStockTakingRowsByFilterError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let item_ids = params.item_ids;
    let supplier_numbers = params.supplier_numbers;
    let stock_point_ids = params.stock_point_ids;
    let stock_location_ids = params.stock_location_ids;
    let transaction_date = params.transaction_date;
    let item_id_search = params.item_id_search;
    let item_description_search = params.item_description_search;
    let exclude_zero_balance_items = params.exclude_zero_balance_items;
    let exclude_non_inbound_items = params.exclude_non_inbound_items;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}/addrows",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("itemIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "itemIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = supplier_numbers {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("supplierNumbers".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "supplierNumbers",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = stock_point_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("stockPointIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "stockPointIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = stock_location_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("stockLocationIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "stockLocationIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = transaction_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("transactionDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_id_search {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemIdSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_description_search {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemDescriptionSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_zero_balance_items {
        local_var_req_builder =
            local_var_req_builder.query(&[("excludeZeroBalanceItems", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_non_inbound_items {
        local_var_req_builder =
            local_var_req_builder.query(&[("excludeNonInboundItems", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddStockTakingRowsByFilterError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Stock Taking document.  The only mandatory fields are <code>name</code> and <code>responsible</code>.  <code>state</code> will be set to <code>planning</code> for a newly created document.   The <code>date</code>-field is not mandatory for documents in state <code>planning</code>.  However, when you update the state to <code>started</code> you have to provide a date.   <code>name</code> is a descriptive name of the stock taking.   <code>responsible</code> is the name of the responsible for the stock taking.   <code>rows</code> are added after creation by using the addRows-method.   <code>projectId</code> and <code>costCenterCode</code> are used for book-keeping, when the  Stock Taking document is released.   The field <code>usingStockPoints</code> is set from Warehouse system settings upon creation.  If multiple stockpoints is used, then the rows will be per item-stockPoint-stockLocation.  If multiple stockpoints is NOT used, then the rows will be per item-stockLocation.
pub async fn create_stock_taking_resource(
    configuration: &configuration::Configuration,
    params: CreateStockTakingResourceParams,
) -> Result<crate::http::models::StockTaking, Error<CreateStockTakingResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let stock_taking = params.stock_taking;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&stock_taking);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateStockTakingResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Permanently deletes a Stock Taking document and its rows.   Only for documents in state <code>planning</code> and <code>started</code>.
pub async fn delete_stock_taking(
    configuration: &configuration::Configuration,
    params: DeleteStockTakingParams,
) -> Result<(), Error<DeleteStockTakingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteStockTakingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove single row by id from the Stock Taking document.
pub async fn delete_stock_taking_row(
    configuration: &configuration::Configuration,
    params: DeleteStockTakingRowParams,
) -> Result<i32, Error<DeleteStockTakingRowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let row_id = params.row_id;

    let local_var_client = &local_var_configuration.client;

    let row_id = crate::http::apis::urlencode(row_id);
    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}/rows/{row_id}",
        local_var_configuration.base_path,
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteStockTakingRowError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove all rows matching the filter parameters from the Stock Taking document.
pub async fn delete_stock_taking_row_by_filter(
    configuration: &configuration::Configuration,
    params: DeleteStockTakingRowByFilterParams,
) -> Result<i32, Error<DeleteStockTakingRowByFilterError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let item_ids = params.item_ids;
    let supplier_numbers = params.supplier_numbers;
    let stock_point_ids = params.stock_point_ids;
    let stock_location_ids = params.stock_location_ids;
    let transaction_date = params.transaction_date;
    let item_id_search = params.item_id_search;
    let item_description_search = params.item_description_search;
    let exclude_zero_balance_items = params.exclude_zero_balance_items;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}/rows",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("itemIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "itemIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = supplier_numbers {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("supplierNumbers".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "supplierNumbers",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = stock_point_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("stockPointIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "stockPointIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = stock_location_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("stockLocationIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "stockLocationIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = transaction_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("transactionDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_id_search {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemIdSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_description_search {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemDescriptionSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_zero_balance_items {
        local_var_req_builder =
            local_var_req_builder.query(&[("excludeZeroBalanceItems", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteStockTakingRowByFilterError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>      Sortable fields:      <code>id</code>,      <code>name</code>,      <code>date</code>,      <code>responsible</code>,      <code>state</code>  </p>
pub async fn get_all_stock_taking_resource(
    configuration: &configuration::Configuration,
    params: GetAllStockTakingResourceParams,
) -> Result<Vec<crate::http::models::StockTaking>, Error<GetAllStockTakingResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let state = params.state;
    let item_id = params.item_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = state {
        local_var_req_builder =
            local_var_req_builder.query(&[("state", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllStockTakingResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// A candidate row is a combination of itemId, stockPointId and stockLocationId  that can be added to the Stock Taking document.   Rows already added to the Stock Taking are excluded from this list.
pub async fn get_candidate_rows(
    configuration: &configuration::Configuration,
    params: GetCandidateRowsParams,
) -> Result<Vec<crate::http::models::StockTakingRow>, Error<GetCandidateRowsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let item_ids = params.item_ids;
    let supplier_numbers = params.supplier_numbers;
    let stock_point_ids = params.stock_point_ids;
    let stock_location_ids = params.stock_location_ids;
    let transaction_date = params.transaction_date;
    let item_id_search = params.item_id_search;
    let item_description_search = params.item_description_search;
    let exclude_zero_balance_items = params.exclude_zero_balance_items;
    let include_non_inbound_items = params.include_non_inbound_items;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}/candidates",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("itemIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "itemIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = supplier_numbers {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("supplierNumbers".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "supplierNumbers",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = stock_point_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("stockPointIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "stockPointIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = stock_location_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("stockLocationIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "stockLocationIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = transaction_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("transactionDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_id_search {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemIdSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_description_search {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemDescriptionSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_zero_balance_items {
        local_var_req_builder =
            local_var_req_builder.query(&[("excludeZeroBalanceItems", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_non_inbound_items {
        local_var_req_builder =
            local_var_req_builder.query(&[("includeNonInboundItems", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCandidateRowsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_rows(
    configuration: &configuration::Configuration,
    params: GetRowsParams,
) -> Result<Vec<crate::http::models::StockTakingRow>, Error<GetRowsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let item_ids = params.item_ids;
    let supplier_numbers = params.supplier_numbers;
    let stock_point_ids = params.stock_point_ids;
    let stock_location_ids = params.stock_location_ids;
    let transaction_date = params.transaction_date;
    let item_id_search = params.item_id_search;
    let item_description_search = params.item_description_search;
    let exclude_zero_balance_items = params.exclude_zero_balance_items;
    let secondarysortby = params.secondarysortby;
    let secondaryorder = params.secondaryorder;
    let state_filter = params.state_filter;
    let starting_row_no = params.starting_row_no;
    let starting_item_id = params.starting_item_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}/rows",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("itemIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "itemIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = supplier_numbers {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("supplierNumbers".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "supplierNumbers",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = stock_point_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("stockPointIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "stockPointIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = stock_location_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .iter()
                    .map(|p| ("stockLocationIds".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "stockLocationIds",
                &local_var_str
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(","),
            )]),
        };
    }
    if let Some(ref local_var_str) = transaction_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("transactionDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_id_search {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemIdSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_description_search {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemDescriptionSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_zero_balance_items {
        local_var_req_builder =
            local_var_req_builder.query(&[("excludeZeroBalanceItems", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = secondarysortby {
        local_var_req_builder =
            local_var_req_builder.query(&[("secondarysortby", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = secondaryorder {
        local_var_req_builder =
            local_var_req_builder.query(&[("secondaryorder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = state_filter {
        local_var_req_builder =
            local_var_req_builder.query(&[("stateFilter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = starting_row_no {
        local_var_req_builder =
            local_var_req_builder.query(&[("startingRowNo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = starting_item_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("startingItemId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRowsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_stock_taking_resource(
    configuration: &configuration::Configuration,
    params: GetStockTakingResourceParams,
) -> Result<crate::http::models::StockTaking, Error<GetStockTakingResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStockTakingResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The document will be locked and bookkept.  The Stock Taking document state will be set to <code>completed</code>.  The stock amount will be adjusted according to the stock taken quantity.
pub async fn release_stock_taking_resource(
    configuration: &configuration::Configuration,
    params: ReleaseStockTakingResourceParams,
) -> Result<(), Error<ReleaseStockTakingResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}/release",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ReleaseStockTakingResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates can only be done when state is <code>planning</code> or <code>started</code>.   All updatable fields (<code>date</code>, <code>name</code>, <code>responsible</code>,  <code>state</code>, <code>sortingId</code>, <code>costCenterCode</code>, <code>projectId</code>)  in the document head are set to supplied values.   You cannot set <code>state</code> to <code>completed</code> or <code>voided</code>. Use endpoints  release or void for this.   The <code>date</code>-field is mandatory for documents in state <code>started</code>.   When state is <code>started</code> you use this endpoint for setting the stock taken quantity.  Only existing rows can be updated - no new rows will be created (use the addRows endpoint for this).  Only the supplied rows will be updated. I.e. you don't have to send in <strong>all</strong>  document rows - just supply the rows you want to set stockTakenQuantity for. Just make sure  to always include all the fields from the document head as mentioned above.   The mandatory fields on the (optionally supplied) rows are: <code>itemId</code>,  <code>stockPointId</code>, <code>stockLocationId</code>.  Fields <code>countedBy</code> and <code>stockTakenQuantity</code> are technically  not mandatory, but will be set to null if you don't supply them.
pub async fn update_stock_taking_resource(
    configuration: &configuration::Configuration,
    params: UpdateStockTakingResourceParams,
) -> Result<crate::http::models::StockTaking, Error<UpdateStockTakingResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let stock_taking = params.stock_taking;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&stock_taking);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateStockTakingResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sets the Stock Taking document state to <code>voided</code>.   Only documents in state <code>planning</code> and <code>started</code>  can be voided. A <code>completed</code> document may not be voided.
pub async fn void_stock_taking(
    configuration: &configuration::Configuration,
    params: VoidStockTakingParams,
) -> Result<(), Error<VoidStockTakingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stocktaking-v1/{id}/void",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<VoidStockTakingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/*
 * # Documentation   The Fortnox API is organized around REST. This means that weâ€™ve designed it to have resource-oriented URLs and be as predictable as possible for you as developer.  It also means that we use HTTP status codes when something goes wrong and HTTP verbs understod by many API clients around the web.  We use a modified version of OAuth2 for authentication to offer a secure way for both you and our users to interact.  The API is generally built to support both XML and JSON but in this documentation all the examples will be in JSON.  We encourage you to read all the articles in the [general information section](https://developer.fortnox.se/general/)</a> first, before going forward and learning about the different resources.  This to ensure you get an understanding of some of the shared components of the API such as parameters and error handling.  ## Rate limits  The limit is 4 requests per second per access-token. This equals to a bit more than 200 requests per minute.  [Read more about this here.](https://developer.fortnox.se/general/regarding-fortnox-api-rate-limits/)  ## Query parameters  Use query parameters with the ?-character and separate parameters with the &-character.   **Example:**  GET - https://api.fortnox.se/3/invoices?accountnumberfrom=3000&accountnumberto=4000 Read more about our parameters [here](https://developer.fortnox.se/general/parameters/)   Search the documentation using the search field in the top left corner.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`batch_update_response_state`]
#[derive(Clone, Debug, Default)]
pub struct BatchUpdateResponseStateParams {
    /// List of purchase order ids.
    pub ids: Option<Vec<i64>>,
    /// The new response state.
    pub response_state_change: Option<crate::models::ResponseStateChange>,
}

/// struct for passing parameters to the method [`create_purchase_order_resource`]
#[derive(Clone, Debug, Default)]
pub struct CreatePurchaseOrderResourceParams {
    /// <code>PurchaseOrder</code> document.
    pub purchase_order: Option<crate::models::PurchaseOrder>,
}

/// struct for passing parameters to the method [`get_all_purchase_order_resource`]
#[derive(Clone, Debug, Default)]
pub struct GetAllPurchaseOrderResourceParams {
    /// Include only documents where `id` or `internalReference`-field contains the given text (case-insensitive).
    pub q: Option<String>,
    /// Include only documents with the given `supplierNumber`.
    pub supplier_number: Option<String>,
    /// Include only documents with the given `purchaseOrderState`.
    pub state: Option<String>,
    /// Include only documents with the given `itemId`.
    pub item_id: Option<String>,
    /// Include only documents with the given `purchaseType`
    pub purchase_type: Option<String>,
    /// Include only documents where `internalReference' contains the given text (case-insensitive).
    pub internal_reference: Option<String>,
    /// Include only documents where `note`-field contains the given text (case-insensitive).
    pub note: Option<String>,
}

/// struct for passing parameters to the method [`get_attached_notes`]
#[derive(Clone, Debug, Default)]
pub struct GetAttachedNotesParams {
    /// Purchase order id.
    pub id: i64,
}

/// struct for passing parameters to the method [`get_csv_report`]
#[derive(Clone, Debug, Default)]
pub struct GetCsvReportParams {
    /// Include only documents where `id` or `internalReference`-field contains the given text (case-insensitive).
    pub q: Option<String>,
    /// Include only documents with the given `supplierNumber`.
    pub supplier_number: Option<String>,
    /// Include only documents with the given `purchaseOrderState`.
    pub state: Option<String>,
    /// Include only documents with the given `itemId`.
    pub item_id: Option<String>,
    /// Include only documents with the given `purchaseType`
    pub purchase_type: Option<String>,
    /// Include only documents where `internalReference' contains the given text (case-insensitive).
    pub internal_reference: Option<String>,
    /// Include only documents where `note`-field contains the given text (case-insensitive).
    pub note: Option<String>,
    /// True to include the purchase type column, default is false.
    pub show_purchase_type_column: Option<bool>,
}

/// struct for passing parameters to the method [`get_matched_documents`]
#[derive(Clone, Debug, Default)]
pub struct GetMatchedDocumentsParams {
    /// Purchase order id.
    pub id: i64,
}

/// struct for passing parameters to the method [`get_purchase_order_resource`]
#[derive(Clone, Debug, Default)]
pub struct GetPurchaseOrderResourceParams {
    /// Purchase order id.
    pub id: i64,
    /// used for calculating the remaining ordered quantity. null will take the received quantity from all incoming goods
    pub ignore_incoming_goods_id: Option<i64>,
}

/// struct for passing parameters to the method [`send_purchase_order`]
#[derive(Clone, Debug, Default)]
pub struct SendPurchaseOrderParams {
    /// Purchase order id.
    pub id: i64,
    /// see <code>PurchaseOrderMailSettings</code>
    pub settings: Option<crate::models::PurchaseOrderMailSettings>,
}

/// struct for passing parameters to the method [`send_purchase_orders`]
#[derive(Clone, Debug, Default)]
pub struct SendPurchaseOrdersParams {
    /// List of Purchase order ids.
    pub purchase_order_ids: Option<Vec<i64>>,
}

/// struct for passing parameters to the method [`set_dropship_manually_completed`]
#[derive(Clone, Debug, Default)]
pub struct SetDropshipManuallyCompletedParams {
    /// Purchase order id.
    pub id: i64,
}

/// struct for passing parameters to the method [`set_manually_completed`]
#[derive(Clone, Debug, Default)]
pub struct SetManuallyCompletedParams {
    /// Purchase order id.
    pub id: i64,
}

/// struct for passing parameters to the method [`update_purchase_order_resource`]
#[derive(Clone, Debug, Default)]
pub struct UpdatePurchaseOrderResourceParams {
    /// Purchase order id.
    pub id: i64,
    /// The <code>PurchaseOrder</code> document.
    pub purchase_order: Option<crate::models::PurchaseOrder>,
}

/// struct for passing parameters to the method [`update_response_state`]
#[derive(Clone, Debug, Default)]
pub struct UpdateResponseStateParams {
    /// Purchase order id.
    pub id: i64,
    /// The new response state.
    pub response_state_change: Option<crate::models::ResponseStateChange>,
}

/// struct for passing parameters to the method [`void_document_purchase_order_resource`]
#[derive(Clone, Debug, Default)]
pub struct VoidDocumentPurchaseOrderResourceParams {
    /// Purchase order id.
    pub id: i64,
}

/// struct for typed errors of method [`batch_update_response_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BatchUpdateResponseStateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_purchase_order_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePurchaseOrderResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_purchase_order_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllPurchaseOrderResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_attached_notes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAttachedNotesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_csv_report`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCsvReportError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_matched_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMatchedDocumentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_purchase_order_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPurchaseOrderResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_purchase_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendPurchaseOrderError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_purchase_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendPurchaseOrdersError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_dropship_manually_completed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetDropshipManuallyCompletedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_manually_completed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetManuallyCompletedError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_purchase_order_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePurchaseOrderResourceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_response_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateResponseStateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`void_document_purchase_order_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VoidDocumentPurchaseOrderResourceError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

pub async fn batch_update_response_state(
    configuration: &configuration::Configuration,
    params: BatchUpdateResponseStateParams,
) -> Result<Vec<crate::models::PurchaseOrder>, Error<BatchUpdateResponseStateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ids = params.ids;
    let response_state_change = params.response_state_change;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/response",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("ids".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "ids",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&response_state_change);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BatchUpdateResponseStateError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_purchase_order_resource(
    configuration: &configuration::Configuration,
    params: CreatePurchaseOrderResourceParams,
) -> Result<crate::models::PurchaseOrder, Error<CreatePurchaseOrderResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let purchase_order = params.purchase_order;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&purchase_order);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreatePurchaseOrderResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>      List purchase orders matching the given parameters.  </p>  <p>      Sortable fields:      <code>id</code>,      <code>supplier_number</code>,      <code>order_date</code>,      <code>internal_reference</code>,      <code>response_state</code>,      <code>delivery_date</code>  </p>
pub async fn get_all_purchase_order_resource(
    configuration: &configuration::Configuration,
    params: GetAllPurchaseOrderResourceParams,
) -> Result<Vec<crate::models::PurchaseOrder>, Error<GetAllPurchaseOrderResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let q = params.q;
    let supplier_number = params.supplier_number;
    let state = params.state;
    let item_id = params.item_id;
    let purchase_type = params.purchase_type;
    let internal_reference = params.internal_reference;
    let note = params.note;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = supplier_number {
        local_var_req_builder =
            local_var_req_builder.query(&[("supplierNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = state {
        local_var_req_builder =
            local_var_req_builder.query(&[("state", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = purchase_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("purchaseType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = internal_reference {
        local_var_req_builder =
            local_var_req_builder.query(&[("internalReference", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = note {
        local_var_req_builder =
            local_var_req_builder.query(&[("note", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllPurchaseOrderResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get notes for a purchase order.
pub async fn get_attached_notes(
    configuration: &configuration::Configuration,
    params: GetAttachedNotesParams,
) -> Result<Vec<crate::models::PurchaseOrderRowNote>, Error<GetAttachedNotesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}/notes",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAttachedNotesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_csv_report(
    configuration: &configuration::Configuration,
    params: GetCsvReportParams,
) -> Result<String, Error<GetCsvReportError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let q = params.q;
    let supplier_number = params.supplier_number;
    let state = params.state;
    let item_id = params.item_id;
    let purchase_type = params.purchase_type;
    let internal_reference = params.internal_reference;
    let note = params.note;
    let show_purchase_type_column = params.show_purchase_type_column;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/csv",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = supplier_number {
        local_var_req_builder =
            local_var_req_builder.query(&[("supplierNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = state {
        local_var_req_builder =
            local_var_req_builder.query(&[("state", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = item_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("itemId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = purchase_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("purchaseType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = internal_reference {
        local_var_req_builder =
            local_var_req_builder.query(&[("internalReference", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = note {
        local_var_req_builder =
            local_var_req_builder.query(&[("note", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = show_purchase_type_column {
        local_var_req_builder =
            local_var_req_builder.query(&[("showPurchaseTypeColumn", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCsvReportError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a list of <code>DocumentReference</code> of linked/connected purchase orders to incoming goods and/or invoice document.
pub async fn get_matched_documents(
    configuration: &configuration::Configuration,
    params: GetMatchedDocumentsParams,
) -> Result<Vec<crate::models::DocumentReference>, Error<GetMatchedDocumentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}/matches",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMatchedDocumentsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_purchase_order_resource(
    configuration: &configuration::Configuration,
    params: GetPurchaseOrderResourceParams,
) -> Result<crate::models::PurchaseOrder, Error<GetPurchaseOrderResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let ignore_incoming_goods_id = params.ignore_incoming_goods_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ignore_incoming_goods_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("ignoreIncomingGoodsId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetPurchaseOrderResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sends the purchase order with the specified <code>id</code> to the recipient and sets the purchase order state to SENT
pub async fn send_purchase_order(
    configuration: &configuration::Configuration,
    params: SendPurchaseOrderParams,
) -> Result<(), Error<SendPurchaseOrderError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let settings = params.settings;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}/send",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&settings);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<SendPurchaseOrderError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn send_purchase_orders(
    configuration: &configuration::Configuration,
    params: SendPurchaseOrdersParams,
) -> Result<(), Error<SendPurchaseOrdersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let purchase_order_ids = params.purchase_order_ids;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/sendpurchaseorders",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&purchase_order_ids);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<SendPurchaseOrdersError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The dropship order will be treated as fully received.  Any remaining quantity will be ignored.
pub async fn set_dropship_manually_completed(
    configuration: &configuration::Configuration,
    params: SetDropshipManuallyCompletedParams,
) -> Result<crate::models::ReleaseParentOrder, Error<SetDropshipManuallyCompletedError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}/dropshipcomplete",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetDropshipManuallyCompletedError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The purchase order will be treated as fully received.  Any remaining quantity will be ignored.
pub async fn set_manually_completed(
    configuration: &configuration::Configuration,
    params: SetManuallyCompletedParams,
) -> Result<(), Error<SetManuallyCompletedError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}/complete",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<SetManuallyCompletedError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_purchase_order_resource(
    configuration: &configuration::Configuration,
    params: UpdatePurchaseOrderResourceParams,
) -> Result<crate::models::PurchaseOrder, Error<UpdatePurchaseOrderResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let purchase_order = params.purchase_order;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&purchase_order);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdatePurchaseOrderResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_response_state(
    configuration: &configuration::Configuration,
    params: UpdateResponseStateParams,
) -> Result<crate::models::PurchaseOrder, Error<UpdateResponseStateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let response_state_change = params.response_state_change;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}/response",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&response_state_change);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateResponseStateError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn void_document_purchase_order_resource(
    configuration: &configuration::Configuration,
    params: VoidDocumentPurchaseOrderResourceParams,
) -> Result<(), Error<VoidDocumentPurchaseOrderResourceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/purchaseorders-v1/{id}/void",
        local_var_configuration.base_path,
        id = id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<VoidDocumentPurchaseOrderResourceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

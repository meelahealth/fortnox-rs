/*
 * # Documentation   The Fortnox API is organized around REST. This means that weâ€™ve designed it to have resource-oriented URLs and be as predictable as possible for you as developer.  It also means that we use HTTP status codes when something goes wrong and HTTP verbs understod by many API clients around the web.  We use a modified version of OAuth2 for authentication to offer a secure way for both you and our users to interact.  The API is generally built to support both XML and JSON but in this documentation all the examples will be in JSON.  We encourage you to read all the articles in the [general information section](https://developer.fortnox.se/general/)</a> first, before going forward and learning about the different resources.  This to ensure you get an understanding of some of the shared components of the API such as parameters and error handling.  ## Rate limits  The limit is 4 requests per second per access-token. This equals to a bit more than 200 requests per minute.  [Read more about this here.](https://developer.fortnox.se/general/regarding-fortnox-api-rate-limits/)  ## Query parameters  Use query parameters with the ?-character and separate parameters with the &-character.   **Example:**  GET - https://api.fortnox.se/3/invoices?accountnumberfrom=3000&accountnumberto=4000 Read more about our parameters [here](https://developer.fortnox.se/general/parameters/)   Search the documentation using the search field in the top left corner.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`append_stock_locations`]
#[derive(Clone, Debug, Default)]
pub struct AppendStockLocationsParams {
    /// stock point id
    pub id: String,
    /// A list of <code>StockLocations</code> to append.
    pub stock_locations: Option<Vec<crate::models::StockLocation>>,
}

/// struct for passing parameters to the method [`create`]
#[derive(Clone, Debug, Default)]
pub struct CreateParams {
    /// stock point
    pub stock_point: Option<crate::models::StockPoint>,
}

/// struct for passing parameters to the method [`delete`]
#[derive(Clone, Debug, Default)]
pub struct DeleteParams {
    /// id
    pub id: String,
}

/// struct for passing parameters to the method [`get_all`]
#[derive(Clone, Debug, Default)]
pub struct GetAllParams {
    /// filters on stock point code or name.
    pub q: Option<String>,
    /// filter on stock point state
    pub state: Option<String>,
}

/// struct for passing parameters to the method [`get_by_ambiguous_id`]
#[derive(Clone, Debug, Default)]
pub struct GetByAmbiguousIdParams {
    /// stock point code, or stock point id
    pub id: String,
}

/// struct for passing parameters to the method [`get_many`]
#[derive(Clone, Debug, Default)]
pub struct GetManyParams {
    /// stock point ids (comma separated list of UUIDs)
    pub ids: Option<Vec<uuid::Uuid>>,
    /// filter on <code>StockPointState</code>, default is to include ALL stock points.
    pub state: Option<String>,
}

/// struct for passing parameters to the method [`get_stock_locations_by_ambiguous_id`]
#[derive(Clone, Debug, Default)]
pub struct GetStockLocationsByAmbiguousIdParams {
    /// stock point id or code
    pub id: String,
    /// filters on stock location code or name.
    pub q: Option<String>,
}

/// struct for passing parameters to the method [`update`]
#[derive(Clone, Debug, Default)]
pub struct UpdateParams {
    /// id
    pub id: String,
    /// complete representation of stock point including stock locations.
    pub stock_point: Option<crate::models::StockPoint>,
}

/// struct for typed errors of method [`append_stock_locations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppendStockLocationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_by_ambiguous_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetByAmbiguousIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_many`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetManyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_stock_locations_by_ambiguous_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStockLocationsByAmbiguousIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateError {
    UnknownValue(serde_json::Value),
}

/// Add new stock locations to specific <code>StockPoint</code>.   If you include an already existing stock location code, it will be ignored.
pub async fn append_stock_locations(
    configuration: &configuration::Configuration,
    params: AppendStockLocationsParams,
) -> Result<Vec<crate::models::StockLocation>, Error<AppendStockLocationsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let stock_locations = params.stock_locations;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stockpoints-v1/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&stock_locations);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AppendStockLocationsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Both <code>code</code> and <code>name</code> are mandatory.   If you want to set a custom delivery address for this stock point,  you must remember to set <code>usingCompanyAddress</code> to <code>false</code>.   Returns 400 <code>alreadyexists</code> if a stock point with same code already exists.   Returns 400 <code>duplicatestocklocations</code> if two or more stock locations have the same code.
pub async fn create(
    configuration: &configuration::Configuration,
    params: CreateParams,
) -> Result<crate::models::StockPoint, Error<CreateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let stock_point = params.stock_point;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stockpoints-v1",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&stock_point);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Note that it is not allowed to delete a stock point that is in use.
pub async fn delete(
    configuration: &configuration::Configuration,
    params: DeleteParams,
) -> Result<crate::models::StockPoint, Error<DeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stockpoints-v1/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List stock points, optionally include a query parameter `q` to filter on stock point code or name.   Use query param `state` to filter on ACTIVE, INACTIVE or ALL (default is to include only ACTIVE stock points).   Stock locations are NOT included in the response.
pub async fn get_all(
    configuration: &configuration::Configuration,
    params: GetAllParams,
) -> Result<Vec<crate::models::StockPoint>, Error<GetAllError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let q = params.q;
    let state = params.state;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stockpoints-v1",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = state {
        local_var_req_builder =
            local_var_req_builder.query(&[("state", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get stock point by id or code.
pub async fn get_by_ambiguous_id(
    configuration: &configuration::Configuration,
    params: GetByAmbiguousIdParams,
) -> Result<crate::models::StockPoint, Error<GetByAmbiguousIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stockpoints-v1/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetByAmbiguousIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get stock points by IDs.   Use query param `state` to filter on ACTIVE, INACTIVE or ALL (default is to include ALL stock points).   Stock locations are NOT included in the response.
pub async fn get_many(
    configuration: &configuration::Configuration,
    params: GetManyParams,
) -> Result<Vec<crate::models::StockPoint>, Error<GetManyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ids = params.ids;
    let state = params.state;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stockpoints-v1/multi",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("ids".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "ids",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = state {
        local_var_req_builder =
            local_var_req_builder.query(&[("state", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetManyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List stock locations for a specific stock point.   Optionally include a query parameter `q` to filter on stock location code or name.
pub async fn get_stock_locations_by_ambiguous_id(
    configuration: &configuration::Configuration,
    params: GetStockLocationsByAmbiguousIdParams,
) -> Result<Vec<crate::models::StockLocation>, Error<GetStockLocationsByAmbiguousIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let q = params.q;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stockpoints-v1/{id}/stocklocations",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStockLocationsByAmbiguousIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remember to supply the complete representation of stock point including stock locations.
pub async fn update(
    configuration: &configuration::Configuration,
    params: UpdateParams,
) -> Result<crate::models::StockPoint, Error<UpdateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let stock_point = params.stock_point;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/warehouse/stockpoints-v1/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&stock_point);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
